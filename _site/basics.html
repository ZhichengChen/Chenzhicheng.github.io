<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>基础一</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="/css/syntax.css">

        <!-- Custom CSS -->
        <link rel="stylesheet" href="/css/b.css">

    </head>
    <body>
        <div class="topbar">
          <div class="fill">
            <div class="container fixed">
              <h3>
                <a href ="/" class="brand">基础一</a>
              </h3>
              <ul class="nav secondary-nav">
                
                
                <li>
                  <a href ="basics-continued.html" >下一节>></a>
                </li>
                
              </ul>
            </div>
          </div>
        </div>

        <div class="container" style="padding-top:60px;">
          <div id="post">
<p>课程包括</p>

<ul>
<li>关于课程 About this class</li>

<li>表达式 experssions</li>

<li>值 values</li>

<li>函数 functions</li>

<li>类 classes</li>

<li>继承基础 basic inheritance</li>

<li>接口 traits</li>

<li>类型 types</li>
</ul>

<h2 id='id170'>关于课程</h2>

<p>开始的几周涵盖了基本语句和概念，然后我们会从一些练习开始。</p>

<p>一些例子可能会通过解释器的形式给出，其余的会在源文件里。</p>

<p>通过一个可见的解释器可以让探索问题更容易。</p>

<h3 id='scala'>为什么是Scala</h3>

<ul>
<li>
<p>有表现力 Expressive</p>

<ul>
<li>First-class 函数</li>

<li>闭包 Closures</li>
</ul>
</li>

<li>
<p>简洁 Concise</p>

<ul>
<li>类型推断 Type inference</li>

<li>函数创造文字句法 Literal syntax for function creation</li>
</ul>
</li>

<li>
<p>Java 互操作</p>

<ul>
<li>可以重用Java 类库</li>

<li>可以重用Java 工具</li>

<li>没有性能损失 No performance penalty</li>
</ul>
</li>
</ul>

<h3 id='scala_'>Scala 怎么样</h3>

<ul>
<li>
<p>编译成java 字节码</p>
</li>

<li>
<p>可以在任意标准JVM 里运行</p>

<ul>
<li>甚至在一些非标准的JVM 比如Dalvik</li>

<li>Scala 编译器是由Java 编译器的作者写的</li>
</ul>
</li>
</ul>

<h3 id='scala_'>Scala 的一些思考</h3>

<p>Scala 不是一个更好的Java。你应当用一个新的思维来学习它 - 你应该学习在这个课程之外的更多东西。</p>

<h3 id='id171'>从解释器开始</h3>

<p>从sbt 控制台开始。</p>
<div class='highlight'><pre><code class='bash'> <span class='nv'>$ </span>sbt console
 
 <span class='o'>[</span>...<span class='o'>]</span>
 
 Welcome to Scala version 2.8.0.final <span class='o'>(</span>Java HotSpot<span class='o'>(</span>TM<span class='o'>)</span> 64-Bit Server VM, Java 1.6.0_20<span class='o'>)</span>.
 Type in expressions to have them evaluated.
 Type :help <span class='k'>for </span>more information.
 
 scala&gt; 
</code></pre></div>
<h2 id='id172'>表达式</h2>
<div class='highlight'><pre><code class='bash'>scala&gt; 1 + 1
res0: <span class='nv'>Int</span> <span class='o'>=</span> 2

res0:Int <span class='o'>=</span> 2
</code></pre></div>
<p>res0 是解释器自动为你的表达式创建的值名字。它有一个Int 类型包含了一个Integer 2。</p>

<p>(几乎)Scala 里面所有的东西都是一个表达式。</p>

<h2 id='id173'>值</h2>

<p>你也可以为表达式结果指定一个名字。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; val <span class='nv'>two</span> <span class='o'>=</span> 1+1
two: <span class='nv'>Int</span> <span class='o'>=</span> 2
</code></pre></div>
<h3 id='id174'>变量</h3>

<p>如果你想改变绑定的值，你可以使用var 来代替val。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; var <span class='nv'>name</span> <span class='o'>=</span> <span class='s2'>&quot;steve&quot;</span>
name:java.lang.String <span class='o'>=</span> steve

scala&gt; <span class='nv'>name</span> <span class='o'>=</span> <span class='s2'>&quot;marius&quot;</span>
name: java.lang.String <span class='o'>=</span> marius
</code></pre></div>
<h2 id='id175'>函数</h2>

<p>你可以用def 创建一个函数。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; def addOne<span class='o'>(</span>m:Int<span class='o'>)</span>:Int <span class='o'>=</span> m + 1
addOne:<span class='o'>(</span>m:Int<span class='o'>)</span>Int
</code></pre></div>
<p>在Scala 里，你可以为函数参数指定类型签名。然后解释器就会很高兴的把类型签名返回给你。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; val <span class='nv'>three</span> <span class='o'>=</span> addOne<span class='o'>(</span>2<span class='o'>)</span>
three: <span class='nv'>Int</span> <span class='o'>=</span> 3
</code></pre></div>
<p>在没有参数的情况下你可以省略括号。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; def three<span class='o'>()</span> <span class='o'>=</span> 1 + 2
three: <span class='o'>()</span>Int

scala&gt; three<span class='o'>()</span>
res2: <span class='nv'>Int</span> <span class='o'>=</span> 3

scala&gt; three
res3: <span class='nv'>Int</span> <span class='o'>=</span> 3
</code></pre></div>
<h3 id='id176'>匿名函数</h3>

<p>你也可以创建一个匿名函数</p>
<div class='highlight'><pre><code class='bash'>scala&gt; <span class='o'>(</span>x: Int<span class='o'>)</span> <span class='o'>=</span>&gt; x + 1
res2: <span class='o'>(</span>Int<span class='o'>)</span> <span class='o'>=</span>&gt; <span class='nv'>Int</span> <span class='o'>=</span>&lt;<span class='k'>function</span>&gt;
</code></pre></div>
<p>你可传递匿名函数，或者把他们保存到vals里。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; val <span class='nv'>addOne</span> <span class='o'>=</span> <span class='o'>(</span>x: Int<span class='o'>)</span> <span class='o'>=</span>&gt; x + 1
addOne: <span class='o'>(</span>Int<span class='o'>)</span> <span class='o'>=</span>&gt; <span class='nv'>Int</span> <span class='o'>=</span> &lt;function1&gt;

scala&gt; addOne<span class='o'>(</span>1<span class='o'>)</span>
res4: <span class='nv'>Int</span> <span class='o'>=</span> 2
</code></pre></div>
<p>如果你的函数有很多表达式，那么你可以使用 {} 来给自己留点喘息之地。</p>
<div class='highlight'><pre><code class='bash'>def timeTwo<span class='o'>(</span>i: Int<span class='o'>)</span>:Int <span class='o'>=</span> <span class='o'>{</span>
    println<span class='o'>(</span><span class='s2'>&quot;hello world&quot;</span><span class='o'>)</span>
    i * 2
<span class='o'>}</span>
</code></pre></div>
<p>这样来定义匿名函数也是可以的。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; <span class='o'>{</span> i: <span class='nv'>Int</span> <span class='o'>=</span>&gt;
    println<span class='o'>(</span><span class='s2'>&quot;hello world&quot;</span><span class='o'>)</span>
    i * 2 
<span class='o'>}</span>
res0: <span class='o'>(</span>Int<span class='o'>)</span> <span class='o'>=</span>&gt; <span class='nv'>Int</span> <span class='o'>=</span> &lt;<span class='k'>function</span>&gt;
</code></pre></div>
<p>当把匿名函数当作参数传递时，你会经常看见这种用法。</p>

<h3 id='id177'>局部应用</h3>

<p>你可以通过下划线来局部应用一个函数，这像是给你了另一个函数。Scala 使用下划线来代表不同的上下文环境的不同东西，但是通常你可以把它看成是未命名的魔法通配符。在{_ + 2}这个上下文环境意味着一个未命名的参数。你可以这样使用它：</p>
<div class='highlight'><pre><code class='bash'>scala&gt; def adder<span class='o'>(</span>m: Int,n: Int<span class='o'>)</span> <span class='o'>=</span> m + n
adder: <span class='o'>(</span>m: Int,n: Int<span class='o'>)</span>Int
</code></pre></div><div class='highlight'><pre><code class='bash'>scala&gt; val <span class='nv'>add2</span> <span class='o'>=</span> adder<span class='o'>(</span>2, _:Int<span class='o'>)</span>
add2: <span class='o'>(</span>Int<span class='o'>)</span> <span class='o'>=</span>&gt; <span class='nv'>Int</span> <span class='o'>=</span> &lt;function1&gt;

scala&gt; add2<span class='o'>(</span>3<span class='o'>)</span>
res50:Int <span class='o'>=</span> 5
</code></pre></div>
<p>你可局部应用参数列表里的任意一个参数，而不仅仅是最后一个。</p>

<h3 id='curried_functions'>Curried functions</h3>

<p>有时候让别人为你的函数在当下应用一些参数过一会又请用其它参数很有意义。</p>

<p>这是让你构建两个数的乘法的例子。在第一个调用点，你将要决定哪一个是乘数在另一个调用点你又要决定被乘数。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; def muliply<span class='o'>(</span>m: Int<span class='o'>)(</span>n: Int<span class='o'>)</span>: <span class='nv'>Int</span> <span class='o'>=</span> m * n
mutiply: <span class='o'>(</span>m:Int<span class='o'>)(</span>n:Int<span class='o'>)</span>Int
</code></pre></div>
<p>你可以直接用所有的参数来调用它。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; mutiply<span class='o'>(</span>2<span class='o'>)(</span>3<span class='o'>)</span>
res0: <span class='nv'>Int</span> <span class='o'>=</span> 6
</code></pre></div>
<p>你也可以第一步填充第一个参数，第二步填充第二个参数。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; val <span class='nv'>timesTwo</span> <span class='o'>=</span> multiply<span class='o'>(</span>2<span class='o'>)</span> _
timesTwo: <span class='o'>(</span>Int<span class='o'>)</span> <span class='o'>=</span>&gt; <span class='nv'>Int</span> <span class='o'>=</span> &lt;function1&gt;

scala&gt; timesTwo<span class='o'>(</span>3<span class='o'>)</span>
res1: <span class='nv'>Int</span> <span class='o'>=</span> 6
</code></pre></div>
<p>你可以应用于任何含有多个参数的函数然后curry 它。让我们试试之前的adder。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; <span class='o'>(</span>adder _<span class='o'>)</span>.curried
res1: <span class='o'>(</span>Int<span class='o'>)</span> <span class='o'>=</span>&gt; <span class='o'>(</span>Int<span class='o'>)</span> <span class='o'>=</span>&gt; <span class='nv'>Int</span> <span class='o'>=</span> &lt;function1&gt;
</code></pre></div>
<h4 id='id178'>变量长度参数</h4>

<p>方法有一个特殊的语法，可以接受重复类型的参数。要给String 的captitalize 函数应用多个字符串，你可以这样写。</p>
<div class='highlight'><pre><code class='bash'>def capitalizeAll<span class='o'>(</span>args: String*<span class='o'>)</span> <span class='o'>=</span> <span class='o'>{</span>
    args.map <span class='o'>{</span> <span class='nv'>arg</span> <span class='o'>=</span>&gt;
        arg.capitalize
    <span class='o'>}</span>
<span class='o'>}</span>

scala&gt; captitalizeAll<span class='o'>(</span><span class='s2'>&quot;rarity&quot;</span>, <span class='s2'>&quot;applejack&quot;</span><span class='o'>)</span>
res2: Seq<span class='o'>[</span>String<span class='o'>]</span> <span class='o'>=</span> ArrayBuffer<span class='o'>(</span>Rarity, Applejack<span class='o'>)</span>
</code></pre></div>
<h2 id='id179'>类</h2>
<div class='highlight'><pre><code class='bash'>scala&gt; class Calculator<span class='o'>{</span>
     |   val brand: <span class='nv'>String</span> <span class='o'>=</span> <span class='s2'>&quot;HP&quot;</span>
     |   val add<span class='o'>(</span>m: Int,n: Int<span class='o'>)</span>: <span class='nv'>Int</span> <span class='o'>=</span> m + n
     |   <span class='o'>}</span>
defined class Calculator

scala&gt; val <span class='nv'>calc</span> <span class='o'>=</span> new Calculator
calc: <span class='nv'>Calculator</span> <span class='o'>=</span> Calculator

scala&gt; calc.add<span class='o'>(</span>1, 2<span class='o'>)</span>
res1: <span class='nv'>Int</span> <span class='o'>=</span> 3

scala&gt; calc.brand
res2:String <span class='o'>=</span> <span class='s2'>&quot;HP&quot;</span>
</code></pre></div>
<p>Contained 是一个通过def 定义的方法和 val 定义的field 。方法只是可以访问class 的state 的函数。</p>

<h3 id='id180'>构造器</h3>

<p>构造器是一个特殊的方法，他们是在你class 定义代码之外的方法。让我们来扩展我们的Calculator 例子来接受一个构造器参数，然后使用它初始化内部state。</p>
<div class='highlight'><pre><code class='scala'><span class='k'>class</span> <span class='nc'>Calculator</span><span class='o'>(</span><span class='n'>brand</span><span class='k'>:</span><span class='kt'>String</span><span class='o'>){</span>
    <span class='cm'>/**</span>
<span class='cm'>     * 构造器</span>
<span class='cm'>     */</span>
    <span class='k'>val</span> <span class='n'>color</span><span class='k'>:</span> <span class='kt'>String</span> <span class='o'>=</span> <span class='k'>if</span> <span class='o'>(</span><span class='n'>brand</span> <span class='o'>==</span> <span class='s'>&quot;T1&quot;</span><span class='o'>){</span>
        <span class='s'>&quot;blue&quot;</span>
    <span class='o'>}</span> <span class='k'>else</span> <span class='k'>if</span> <span class='o'>(</span><span class='n'>brand</span> <span class='o'>==</span> <span class='s'>&quot;HP&quot;</span><span class='o'>){</span>
        <span class='s'>&quot;black&quot;</span>
    <span class='o'>}</span> <span class='k'>else</span> <span class='o'>{</span>
        <span class='s'>&quot;white&quot;</span>
    <span class='o'>}</span>
    <span class='c1'>// 一个内部方法</span>
    <span class='k'>def</span> <span class='n'>add</span><span class='o'>(</span><span class='n'>m</span><span class='k'>:</span> <span class='kt'>Int</span><span class='o'>,</span><span class='n'>n</span><span class='k'>:</span> <span class='kt'>Int</span><span class='o'>)</span><span class='k'>:</span> <span class='kt'>Int</span> <span class='o'>=</span> <span class='n'>m</span> <span class='o'>+</span> <span class='n'>n</span>
<span class='o'>}</span>
</code></pre></div>
<p>注意上面两种不同的注释方法。</p>

<p>你可以使用构造器来构造一个实例。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; val <span class='nv'>calc</span> <span class='o'>=</span> new Calculator<span class='o'>(</span><span class='s2'>&quot;HP&quot;</span><span class='o'>)</span>
calc: <span class='nv'>Calculator</span> <span class='o'>=</span> Calculator@1e64cc4d

scala&gt; calc.color
res0: <span class='nv'>String</span> <span class='o'>=</span> black
</code></pre></div>
<h3 id='id181'>表达式</h3>

<p>BasciCalulator 例子给我们一个Scala 面向对象表达式的例子。color 值的限定基于if/else 表达式。Scala 是高度面向对象的表达式：很多东西都是公式而不语句。</p>

<h3 id='id182'>旁白：函数和方法</h3>
<div class='highlight'><pre><code class='bash'>scala&gt; class C <span class='o'>{</span>
     |   var <span class='nv'>acc</span> <span class='o'>=</span> 0
     |   def <span class='nv'>minc</span> <span class='o'>=</span> <span class='o'>{</span> acc +<span class='o'>=</span> 1 <span class='o'>}</span>
     |   val <span class='nv'>finc</span> <span class='o'>=</span> <span class='o'>{</span> <span class='o'>()</span> <span class='o'>=</span>&gt; acc +<span class='o'>=</span> 1 <span class='o'>}</span>
     | <span class='o'>}</span>
defined class C

scala&gt; val <span class='nv'>c</span> <span class='o'>=</span> new C
c: <span class='nv'>C</span> <span class='o'>=</span> C@1af1bd6

scala&gt; c.minc // calls c.minc<span class='o'>()</span>

scala&gt; c.finc // returns the <span class='k'>function </span>as a value:
res2: <span class='o'>()</span> <span class='o'>=</span>&gt; <span class='nv'>Unit</span> <span class='o'>=</span> &lt;function0&gt;
</code></pre></div>
<p>当你调用一个没有括号的函数时，你可能会想：“艾马，我觉得我已经知道Scala 的函数怎样工作了，但是实际上不是这样不对。难道它们只是在某些时候需要括号？” 你可能了解函数，但是用方法吧。</p>

<p>实践证明，当你对方法和函数的区别感到迷迷糊糊时你也可以用Scala 来做好多事情。如果你是Scala 小白，并且google 了一下 difference scala function method，你可能就更糊涂了。这并不是意味着你在使用Scala 的时候稀里糊涂。仅仅是因为函数和方法的区别太细微了，弄明白它得扣好多语言的很深的部分。</p>

<h2 id='id183'>继承基础</h2>
<div class='highlight'><pre><code class='scala'><span class='k'>class</span> <span class='nc'>ScientificCalculator</span><span class='o'>(</span><span class='n'>brand</span><span class='k'>:</span> <span class='kt'>String</span><span class='o'>)</span> <span class='k'>extends</span> <span class='nc'>Calulator</span><span class='o'>(</span><span class='n'>brand</span><span class='o'>)</span> <span class='o'>{</span>
    <span class='k'>def</span> <span class='n'>log</span><span class='o'>(</span><span class='n'>m</span><span class='k'>:</span> <span class='kt'>Double</span><span class='o'>,</span><span class='n'>base</span><span class='k'>:</span> <span class='kt'>Double</span><span class='o'>)</span> <span class='k'>=</span> <span class='n'>math</span><span class='o'>.</span><span class='n'>log</span><span class='o'>(</span><span class='n'>m</span><span class='o'>)</span> <span class='o'>/</span> <span class='n'>math</span><span class='o'>.</span><span class='n'>log</span><span class='o'>(</span><span class='n'>base</span><span class='o'>)</span>
<span class='o'>}</span>
</code></pre></div>
<p>看Effective Scala 里面指出了如果子类是在和超类没什么不同 <a href='http://twitter.github.com/effectivescala/#Types%20and%20Generics-Type%20aliases'>类型别名</a>比extends 好的多。A Tour of Scala 描述了 <a href='http://www.scala-lang.org/node/125'>子类</a>。</p>

<h3 id='id184'>重载方法</h3>
<div class='highlight'><pre><code class='bash'>class EvenMoreScientificCalculator<span class='o'>(</span>brand:String<span class='o'>)</span> extends ScientificCalculator<span class='o'>(</span>brand<span class='o'>)</span> <span class='o'>{</span>
    def log<span class='o'>(</span>m: Int<span class='o'>)</span>:Double <span class='o'>=</span> log<span class='o'>(</span>m,math.exp<span class='o'>(</span>1<span class='o'>))</span>
<span class='o'>}</span>
</code></pre></div>
<h3 id='id185'>抽象类</h3>

<p>你可以定义一个抽象类，一个定义了一些方法却并没有实现的类。子类可以继承自抽象类然后扩展这些方法。你不能为抽象类创建一个实例。</p>
<div class='highlight'><pre><code class='bash'>scala&gt; abstract class Shape <span class='o'>{</span>
    |    def getArea<span class='o'>()</span>:Int //子类必须定义它
    | <span class='o'>}</span>
defined class Shape

scala&gt; class Circle<span class='o'>(</span>r: Int<span class='o'>)</span> extends Shape<span class='o'>{</span>
    |    def getArea<span class='o'>()</span>:Int <span class='o'>=</span> <span class='o'>{</span> r * r * 3<span class='o'>}</span>
    | <span class='o'>}</span>
defined class Circle

scala&gt; val <span class='nv'>s</span> <span class='o'>=</span> new Shape
&lt;console&gt;:8: error: class Shape is abstract; cannot be instantiated
       val <span class='nv'>s</span> <span class='o'>=</span> new Shape
               ^

scala&gt; val <span class='nv'>c</span> <span class='o'>=</span> new Circle<span class='o'>(</span>2<span class='o'>)</span>
c: <span class='nv'>Circle</span> <span class='o'>=</span> Circle@65c0035b
</code></pre></div>
<h2 id='id186'>接口</h2>

<p>接口是一个你可以扩展或者mixin 到你的类的field 和行为的集合。</p>
<div class='highlight'><pre><code class='scala'><span class='k'>trait</span> <span class='nc'>Car</span> <span class='o'>{</span>
    <span class='k'>val</span> <span class='n'>brand</span><span class='k'>:</span> <span class='kt'>String</span>
<span class='o'>}</span>

<span class='k'>trait</span> <span class='nc'>Shiny</span> <span class='o'>{</span>
    <span class='k'>val</span> <span class='n'>shineRefraction</span><span class='k'>:</span> <span class='kt'>Int</span>
<span class='o'>}</span>
</code></pre></div><div class='highlight'><pre><code class='scala'><span class='k'>class</span> <span class='nc'>BMW</span> <span class='k'>extends</span> <span class='nc'>Car</span> <span class='o'>{</span>
    <span class='k'>val</span> <span class='n'>brand</span> <span class='k'>=</span> <span class='s'>&quot;BMW&quot;</span>
<span class='o'>}</span>
</code></pre></div>
<p>一个类可以使用with 关键字扩展自多个接口：</p>
<div class='highlight'><pre><code class='scala'><span class='k'>class</span> <span class='nc'>BMW</span> <span class='k'>extends</span> <span class='nc'>Car</span> <span class='k'>with</span> <span class='nc'>Shiny</span><span class='o'>{</span>
    <span class='k'>val</span> <span class='n'>brand</span> <span class='k'>=</span> <span class='s'>&quot;BMW&quot;</span>
    <span class='k'>val</span> <span class='n'>shineRefraction</span> <span class='k'>=</span> <span class='mi'>12</span>
<span class='o'>}</span>
</code></pre></div>
<p>也可以看看Effective Scala 里面对<a href='http://twitter.github.com/effectivescala/#Object+oriented+programming-Traits'>接口</a>的观点。</p>

<p><em>你什么时候想要用接口来代替一个抽象类？</em>如果你想定义一个类接口的类型，你可呢姑娘会发现在接口和抽象类之间选择会很痛苦。每一个都会让你定义一些行为，然后通过扩展类来定义其它的行为。一些好的建议：</p>

<ul>
<li>尽量用接口。一个类可以很方便的继承自好多接口，但只能继承自一个clasis。</li>

<li>如果你需要构造参数，用抽象类吧。抽象类构造器可以接受参数，接口就不行了。比如，你不能这样，trait t(i: Int) {}; i 参数是非法的。</li>
</ul>

<p>你不是第一个问这个问题的人。在这里看到更完整的答案,StackOverflow:<a href='http://stackoverflow.com/questions/1991042/scala-traits-vs-abstract-classes'>stackoverflow:Scala traits vs abstract classes</a>，<a href='http://stackoverflow.com/questions/2005681/difference-between-abstract-class-and-trait'>Difference between Abstract Class and Trait</a>,Programming in Scala:<a href='http://www.artima.com/pins1ed/traits.html#12.7'>To trait, or not to tit, or not to trait?</a>。</p>

<h2 id='id187'>类型</h2>

<p>之前，你看到了我们定义了一个接受Int 的函数，Int 就是Number 类型。函数可以是通用的可以接受任何类型。当这发生时，你会看到方括号语法的类型参数介绍。这是一个通用Keys 和Values 的Cache 的例子。</p>
<div class='highlight'><pre><code class='scala'><span class='k'>trait</span> <span class='nc'>Cache</span><span class='o'>[</span><span class='kt'>K</span>,<span class='kt'>V</span><span class='o'>]</span> <span class='o'>{</span>
    <span class='k'>def</span> <span class='n'>get</span><span class='o'>(</span><span class='n'>key</span><span class='k'>:</span> <span class='kt'>k</span><span class='o'>)</span><span class='k'>:</span> <span class='kt'>V</span>
    <span class='k'>def</span> <span class='n'>put</span><span class='o'>(</span><span class='n'>key</span><span class='k'>:</span> <span class='kt'>K</span><span class='o'>,</span><span class='n'>value</span><span class='k'>:</span> <span class='kt'>V</span><span class='o'>)</span>
    <span class='k'>def</span> <span class='n'>delete</span><span class='o'>(</span><span class='n'>key</span><span class='k'>:</span> <span class='kt'>K</span><span class='o'>)</span>
<span class='o'>}</span>
</code></pre></div>
<p>方法也可以有参数介绍介绍：</p>
<div class='highlight'><pre><code class='scala'><span class='k'>def</span> <span class='n'>remove</span><span class='o'>[</span><span class='kt'>K</span><span class='o'>](</span><span class='n'>keys</span><span class='k'>:</span> <span class='kt'>K</span><span class='o'>)</span>

<span class='o'>}</span>
</code></pre></div>
</div>

        </div>

        <div id="footer">
          <div class="inner">
            <div class="container">
              <p>
                由<a href="http://twitter.com/twitter" target="_blank">@twitter</a> 的<a href="http://twitter.com/stevej" target="_blank">@stevej</a>, <a href="http://twitter.com/marius" target="_blank">@marius</a> 构建，特别感谢 <a href="http://twitter.com/lahosken" target="_blank">@lahosken</a>  的 <a href="http://twitter.com/evanm" target="_blank">@evanm</a>，<a href="http://twitter.com/sprsquish" target="_blank">@sprsquish</a>，<a href="http://twitter.com/kevino" target="_blank">@kevino</a>，<a href="http://twitter.com/zuercher" target="_blank">@zuercher</a>，<a href="http://twitter.com/timtrueman" target="_blank">@timtrueman</a>，<a href="http://twitter.com/wickman" target="_blank">@wickman</a> 和<a href="http://twitter.com/mccv" target="_blank">@mccv</a>; 俄语由 <a href="https://github.com/appigram">appigram</a> 翻译<br>
                开源依照 <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License v2.0</a>.
              </p>
            </div>
          </div>
        </div>
    </body>
</html>
